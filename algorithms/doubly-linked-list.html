<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta
            name="viewport"
            content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
        />

        <title>vadyushkins</title>
        <link rel="icon" type="image/x-icon" href="../dist/favicon.ico">

        <link rel="stylesheet" href="../dist/reset.css" />
        <link rel="stylesheet" href="../dist/reveal.css" />
        <link rel="stylesheet" href="../dist/theme/my-simple.css" />

        <!-- Theme used for syntax highlighted code -->
        <!-- All themes https://github.com/highlightjs/highlight.js/tree/main/src/styles -->
        <link rel="stylesheet" href="../plugin/highlight/atom-one-light.css" />
    </head>
    <body>
        <div id="hidden" style="display:none;">
            <div id="header">
                <a href="../index.html">vadyushkins</a><a href="./index.html#data-structures">&#183;Algorithms</a><a href="./doubly-linked-list.html">&#183;DLL</a>
            </div>
        </div>
        <div class="reveal">
            <div class="slides">
                <section>
                    <section>
                        <h2>Doubly Linked List</h2>
                        <a href="#/python">Python</a>
                        <a href="#/cpp">C++</a>
                    </section>
                    <section>
                        <p>
                        <table>
                            <tr>
                                <td>push back</td>
                                <td>$O(1)$</td>
                            </tr>
                            <tr>
                                <td>push front</td>
                                <td>$O(1)$</td>
                            </tr>
                            <tr>
                                <td>pop back</td>
                                <td>$O(1)$</td>
                            </tr>
                            <tr>
                                <td>pop front</td>
                                <td>$O(1)$</td>
                            </tr>
                            <tr>
                                <td>find item</td>
                                <td>$O(N)$</td>
                            </tr>
                        </table>
                        </p>
                    </section>
                </section>

                <section>
                    <section>
                        <h2>Description</h2>
                    </section>
                    <section>
                        <h2>Structure</h2>
                        <img data-src="./static/dll/dll-structure.svg"/>
                    </section>
                    <section>
                        <p>
                            <b>Node Structure</b>: A node in a doubly linked list
                            typically consists of three components: data, next pointer and previous pointer.
                        </p>
                        <p>
                            <b>Data</b>: It holds the actual value or data associated with the node.
                        </p>
                        <p>
                            <b>Next Pointer</b>: It stores the memory address (reference) of the next node in the list.
                        </p>
                        <p>
                            <b>Previous Pointer</b>: It stores the memory address (reference) of the previous node in the list.
                        </p>
                        <p>
                            <b>Head and Tail</b>: The linked list is accessed through the head node,
                            which points to the first node in the list.
                            The last node in the list points to NULL, indicating the end of the list.
                            This node is known as the tail node.
                        </p>
                    </section>
                    <section>
                        <h2>Push back</h2>
                        <p>
                            <ol>
                                <li>Create a new node.</li>
                                <li>Set the next pointer of tail node to the new node.</li>
                                <li>Set the previous pointer of new node to the tail node.</li>
                                <li>Set the tail pointer to the new node.</li>
                            </ol>
                        </p>
                        <img data-src="./static/dll/dll-push-back.svg"/>
                    </section>
                    <section>
                        <h2>Push front</h2>
                        <p>
                            <ol>
                                <li>Create a new node.</li>
                                <li>Set the next pointer of the new node to the head node.</li>
                                <li>Set the previous pointer of the head node to the new node.</li>
                                <li>Set the head pointer to the new node.</li>
                            </ol>
                        </p>
                        <img data-src="./static/dll/dll-push-front.svg"/>
                    </section>
                    <section>
                        <h2>Pop back</h2>
                        <p>
                            <ol>
                                <li>Save the previous pointer of the tail node to the temporary pointer.</li>
                                <li>Set the next pointer of tail's previous node to NULL.</li>
                                <li>Free the tail node.</li>
                                <li>Set the tail pointer to the temporary pointer.</li>
                            </ol>
                        </p>
                        <img data-src="./static/dll/dll-pop-back.svg"/>
                    </section>
                    <section>
                        <h2>Pop front</h2>
                        <p>
                            <ol>
                                <li>Save the next pointer of the head node to the temporary pointer.</li>
                                <li>Set the previous pointer of head's next node to NULL.</li>
                                <li>Free the head node.</li>
                                <li>Set the head pointer to the temporary pointer.</li>
                            </ol>
                        </p>
                        <img data-src="./static/dll/dll-pop-front.svg"/>
                    </section>
                    <section>
                        <h2>Find item</h2>
                        <p>
                            <ol>
                                <li>Set current pointer to the head pointer.</li>
                                <li>
                                    Compare current node data with finding item data in cycle:
                                    <ul>
                                        <li>If they are equal, we found the right node.</li>
                                        <li>If they are not equal, set current pointer to the current node next pointer.</li>
                                    </ul>
                                </li>
                                <li>If current node is NULL, then there is no right node in the list.</li>
                            </ol>
                        </p>
                    </section>
                </section>

                <section>
                    <section>
                        <h2>Example</h2>
                    </section>
                    <section>
                        <p>
                            Let's look at several examples of working with a doubly linked list.
                            We start with empty list.
                        </p>
                        <img data-src="./static/dll/dll-example-0.svg"/>
                    </section>
                    <section>
                        Push front data = <code inline>1</code>.
                        <br>
                        <img data-src="./static/dll/dll-example-1.svg"/>
                    </section>
                    <section>
                        Push front data = <code inline>2</code>.
                        <br>
                        <img data-src="./static/dll/dll-example-2.svg"/>
                    </section>
                    <section>
                        Push back data = <code inline>3</code>.
                        <br>
                        <img data-src="./static/dll/dll-example-3.svg"/>
                    </section>
                    <section>
                        Pop front.
                        <br>
                        <img data-src="./static/dll/dll-example-4.svg"/>
                    </section>
                    <section>
                        Pop back.
                        <br>
                        <img data-src="./static/dll/dll-example-5.svg"/>
                    </section>
                    <section>
                        Find data = <code inline>4</code>.
                        <br>
                        <p>
                            <ol>
                                <li>Set current pointer to the head pointer.</li>
                                <li>Current node data = <code inline>1</code>
                                    is not equal to data = <code inline>4</code>.</li>
                                <li>Set current pointer to the current node next pointer.</li>
                            </ol>
                        </p>
                        <br>
                        <img data-src="./static/dll/dll-example-6.svg"/>
                    </section>
                    <section>
                        Find data = <code inline>4</code>.
                        <br>
                        Current node is NULL, then there is no node with data = <code inline>4</code> in the list.
                        <br>
                        <img data-src="./static/dll/dll-example-7.svg"/>
                    </section>
                </section>

                <section>
                    <section><h2>Code</h2></section>
                    <section id="python">
                        Python
                        <pre><code class="hljs python" data-noescape data-trim data-line-numbers>
                        class DoublyLinkedList:
                            class Node:
                                def __init__(self, data: Any):
                                    self.data = data
                                    self.prev: Optional[DoublyLinkedList.Node] = None
                                    self.next: Optional[DoublyLinkedList.Node] = None
                        
                            def __init__(self):
                                self.head: Optional[DoublyLinkedList.Node] = None
                                self.tail: Optional[DoublyLinkedList.Node] = None
                        
                            def push_back(self, data: Any):
                                if self.tail is None:
                                    self.tail = DoublyLinkedList.Node(data)
                                    self.head = self.tail
                                else:
                                    self.tail.next = DoublyLinkedList.Node(data)
                                    self.tail.next.prev = self.tail
                                    self.tail = self.tail.next
                        
                            def push_front(self, data: Any):
                                if self.head is None:
                                    self.head = DoublyLinkedList.Node(data)
                                    self.tail = self.head
                                else:
                                    self.head.prev = DoublyLinkedList.Node(data)
                                    self.head.prev.next = self.head
                                    self.head = self.head.prev
                        
                            def pop_back(self):
                                if self.tail is not None:
                                    if self.head.next is None:
                                        self.head = None
                                        self.tail = None
                                    else:
                                        self.tail = self.tail.prev
                                        self.tail.next = None
                        
                            def pop_front(self):
                                if self.head is not None:
                                    if self.head.next is None:
                                        self.head = None
                                        self.tail = None
                                    else:
                                        self.head = self.head.next
                                        self.head.prev = None
                        
                            def find_item(self, data: Any) -> bool:
                                current = self.head
                                while current is not None:
                                    if current.data == data:
                                        return True
                                    else:
                                        current = current.next
                                return False
                        </code></pre>
                    </section>
                    <section id="cpp">
                        C++
                        <pre><code class="hljs cpp" data-noescape data-trim data-line-numbers><script type="text/template">
                            template <std::equality_comparable T>
                            struct DoublyLinkedList {
                                struct Node {
                                    T data;
                                    Node *prev;
                                    Node *next;
                            
                                    explicit Node(T data) {
                                        this->data = data;
                                        this->prev = nullptr;
                                        this->next = nullptr;
                                    }
                            
                                    ~ Node() = default;
                                };
                            
                                Node *head;
                                Node *tail;
                            
                                explicit DoublyLinkedList() {
                                    this->head = nullptr;
                                    this->tail = nullptr;
                                }
                            
                                void push_back(T data) {
                                    if (this->tail == nullptr) {
                                        this->tail = new Node(data);
                                        this->head = tail;
                                    } else {
                                        this->tail->next = new Node(data);
                                        this->tail->next->prev = this->tail;
                                        this->tail = this->tail->next;
                                    }
                                }
                            
                                void push_front(T data) {
                                    if (this->head == nullptr) {
                                        this->head = new Node(data);
                                        this->tail = this->head;
                                    } else {
                                        this->head->prev = new Node(data);
                                        this->head->prev->next = this->head;
                                        this->head = this->head->prev;
                                    }
                                }
                            
                                void pop_back() {
                                    if (this->tail != nullptr) {
                                        if (this->head->next == nullptr) {
                                            delete this->head;
                                            this->head = nullptr;
                                            this->tail = nullptr;
                                        } else {
                                            Node *new_tail = this->tail->prev;
                                            this->tail->prev->next = nullptr;
                                            this->tail->prev = nullptr;
                                            delete this->tail;
                                            this->tail = new_tail;
                                        }
                                    }
                                }
                            
                                void pop_front() {
                                    if (this->head != nullptr) {
                                        if (this->head->next == nullptr) {
                                            delete this->head;
                                            this->head = nullptr;
                                            this->tail = nullptr;
                                        } else {
                                            Node *new_head = this->head->next;
                                            this->head->next->prev = nullptr;
                                            this->head->next = nullptr;
                                            delete this->head;
                                            this->head = new_head;
                                        }
                                    }
                                }
                            
                                bool find_item(T data) {
                                    Node *current = this->head;
                                    while (current != nullptr) {
                                        if (current->data == data) {
                                            return true;
                                        } else {
                                            current = current->next;
                                        }
                                    }
                                    return false;
                                }
                            };
                        </script></code></pre>
                    </section>
                </section>
            </div>
        </div>

        <script src="../dist/reveal.js"></script>
        <script src="../plugin/notes/notes.js"></script>
        <script src="../plugin/markdown/markdown.js"></script>
        <script src="../plugin/highlight/highlight.js"></script>
        <script src="../plugin/math/math.js"></script>
        <script src="../js/reveal.js-copycode/plugin/copycode/copycode.js"></script>
        <script>
            // More info about initialization & config:
            // - https://revealjs.com/initialization/
            // - https://revealjs.com/config/
            Reveal.initialize({
                slideNumber: "c/t",
                hash: true,

                width: "100%",
                height: "100%",

                // Learn about plugins: https://revealjs.com/plugins/
                plugins: [
                    RevealMarkdown,
                    RevealHighlight,
                    RevealNotes,
                    RevealMath.KaTeX,
                    CopyCode,
                ],

                // More info about CopyCode plugin
                // - https://github.com/Martinomagnifico/reveal.js-copycode
                copycode: {
                    style: {
                        copybg: "#4078f2",
                        copiedbg: "#4078f2",
                        copycolor: "#000",
                        copiedcolor: "#000",
                    },
                },
            });
        </script>
        <script src="../js/header.js"></script>
    </body>
</html>
